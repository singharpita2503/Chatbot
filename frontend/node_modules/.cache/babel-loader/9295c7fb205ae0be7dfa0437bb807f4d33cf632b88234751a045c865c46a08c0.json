{"ast":null,"code":"import { useState, useReducer, useRef, useCallback, useEffect } from 'react';\nconst NativeSpeechRecognition = typeof window !== \"undefined\" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\nconst isNative = SpeechRecognition => SpeechRecognition === NativeSpeechRecognition;\nvar isAndroid = () => /(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\");\nconst debounce = (func, wait, immediate) => {\n  let timeout;\n  return function () {\n    const context = this;\n    const args = arguments;\n    const later = function () {\n      timeout = null;\n    };\n    const callNow = !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};\nconst concatTranscripts = (...transcriptParts) => {\n  return transcriptParts.map(t => t.trim()).join(\" \").trim();\n};\n// The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\nconst optionalParam = /\\s*\\((.*?)\\)\\s*/g;\nconst optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\nconst namedParam = /(\\(\\?)?:\\w+/g;\nconst splatParam = /\\*/g;\nconst escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\nconst commandToRegExp = command => {\n  if (command instanceof RegExp) {\n    return new RegExp(command.source, \"i\");\n  }\n  command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, (match, optional) => {\n    return optional ? match : \"([^\\\\s]+)\";\n  }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n  return new RegExp(\"^\" + command + \"$\", \"i\");\n};\n// this is from https://github.com/aceakash/string-similarity\nconst compareTwoStringsUsingDiceCoefficient = (first, second) => {\n  first = first.replace(/\\s+/g, \"\").toLowerCase();\n  second = second.replace(/\\s+/g, \"\").toLowerCase();\n  if (!first.length && !second.length) return 1; // if both are empty strings\n  if (!first.length || !second.length) return 0; // if only one is empty string\n  if (first === second) return 1; // identical\n  if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\n  if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\n  const firstBigrams = new Map();\n  for (let i = 0; i < first.length - 1; i++) {\n    const bigram = first.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n    firstBigrams.set(bigram, count);\n  }\n  let intersectionSize = 0;\n  for (let i = 0; i < second.length - 1; i++) {\n    const bigram = second.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n    if (count > 0) {\n      firstBigrams.set(bigram, count - 1);\n      intersectionSize++;\n    }\n  }\n  return 2.0 * intersectionSize / (first.length + second.length - 2);\n};\nconst browserSupportsPolyfills = () => {\n  return typeof window !== \"undefined\" && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\n};\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _async_to_generator$1(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nclass RecognitionManager {\n  setSpeechRecognition(SpeechRecognition) {\n    const browserSupportsRecogniser = !!SpeechRecognition && (isNative(SpeechRecognition) || browserSupportsPolyfills());\n    if (browserSupportsRecogniser) {\n      this.disableRecognition();\n      this.recognition = new SpeechRecognition();\n      this.recognition.continuous = false;\n      this.recognition.interimResults = true;\n      this.recognition.onresult = this.updateTranscript.bind(this);\n      this.recognition.onend = this.onRecognitionDisconnect.bind(this);\n      this.recognition.onerror = this.onError.bind(this);\n    }\n    this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\n  }\n  subscribe(id, callbacks) {\n    this.subscribers[id] = callbacks;\n  }\n  unsubscribe(id) {\n    delete this.subscribers[id];\n  }\n  emitListeningChange(listening) {\n    this.listening = listening;\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onListeningChange\n      } = this.subscribers[id];\n      onListeningChange(listening);\n    });\n  }\n  emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\n    this.isMicrophoneAvailable = isMicrophoneAvailable;\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onMicrophoneAvailabilityChange\n      } = this.subscribers[id];\n      onMicrophoneAvailabilityChange(isMicrophoneAvailable);\n    });\n  }\n  emitTranscriptChange(interimTranscript, finalTranscript) {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onTranscriptChange\n      } = this.subscribers[id];\n      onTranscriptChange(interimTranscript, finalTranscript);\n    });\n  }\n  emitClearTranscript() {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onClearTranscript\n      } = this.subscribers[id];\n      onClearTranscript();\n    });\n  }\n  emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onBrowserSupportsSpeechRecognitionChange,\n        onBrowserSupportsContinuousListeningChange\n      } = this.subscribers[id];\n      onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\n      onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\n    });\n  }\n  disconnect(disconnectType) {\n    if (this.recognition && this.listening) {\n      switch (disconnectType) {\n        case \"ABORT\":\n          this.pauseAfterDisconnect = true;\n          this.abort();\n          break;\n        case \"RESET\":\n          this.pauseAfterDisconnect = false;\n          this.abort();\n          break;\n        case \"STOP\":\n        default:\n          this.pauseAfterDisconnect = true;\n          this.stop();\n      }\n    }\n  }\n  disableRecognition() {\n    if (this.recognition) {\n      this.recognition.onresult = () => {};\n      this.recognition.onend = () => {};\n      this.recognition.onerror = () => {};\n      if (this.listening) {\n        this.stopListening();\n      }\n    }\n  }\n  onError(event) {\n    if (event && event.error && event.error === \"not-allowed\") {\n      this.emitMicrophoneAvailabilityChange(false);\n      this.disableRecognition();\n    }\n  }\n  onRecognitionDisconnect() {\n    this.onStopListening();\n    this.listening = false;\n    if (this.pauseAfterDisconnect) {\n      this.emitListeningChange(false);\n    } else if (this.recognition) {\n      if (this.recognition.continuous) {\n        this.startListening({\n          continuous: this.recognition.continuous\n        });\n      } else {\n        this.emitListeningChange(false);\n      }\n    }\n    this.pauseAfterDisconnect = false;\n  }\n  updateTranscript({\n    results,\n    resultIndex\n  }) {\n    const currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\n    this.interimTranscript = \"\";\n    this.finalTranscript = \"\";\n    for (let i = currentIndex; i < results.length; ++i) {\n      if (results[i].isFinal && (!isAndroid() || results[i][0].confidence > 0)) {\n        this.updateFinalTranscript(results[i][0].transcript);\n      } else {\n        this.interimTranscript = concatTranscripts(this.interimTranscript, results[i][0].transcript);\n      }\n    }\n    let isDuplicateResult = false;\n    if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\n      if (this.previousResultWasFinalOnly) {\n        isDuplicateResult = true;\n      }\n      this.previousResultWasFinalOnly = true;\n    } else {\n      this.previousResultWasFinalOnly = false;\n    }\n    if (!isDuplicateResult) {\n      this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\n    }\n  }\n  updateFinalTranscript(newFinalTranscript) {\n    this.finalTranscript = concatTranscripts(this.finalTranscript, newFinalTranscript);\n  }\n  resetTranscript() {\n    this.disconnect(\"RESET\");\n  }\n  startListening({\n    continuous = false,\n    language\n  } = {}) {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      if (!_this.recognition) {\n        return;\n      }\n      const isContinuousChanged = continuous !== _this.recognition.continuous;\n      const isLanguageChanged = language && language !== _this.recognition.lang;\n      if (isContinuousChanged || isLanguageChanged) {\n        if (_this.listening) {\n          yield _this.stopListening();\n        }\n        _this.recognition.continuous = isContinuousChanged ? continuous : _this.recognition.continuous;\n        _this.recognition.lang = isLanguageChanged ? language : _this.recognition.lang;\n      }\n      if (!_this.listening) {\n        if (!_this.recognition.continuous) {\n          _this.resetTranscript();\n          _this.emitClearTranscript();\n        }\n        try {\n          yield _this.start();\n          _this.emitListeningChange(true);\n        } catch (e) {\n          // DOMExceptions indicate a redundant microphone start - safe to swallow\n          if (!(e instanceof DOMException)) {\n            _this.emitMicrophoneAvailabilityChange(false);\n          }\n        }\n      }\n    })();\n  }\n  abortListening() {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      _this.disconnect(\"ABORT\");\n      _this.emitListeningChange(false);\n      yield new Promise(resolve => {\n        _this.onStopListening = resolve;\n      });\n    })();\n  }\n  stopListening() {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      _this.disconnect(\"STOP\");\n      _this.emitListeningChange(false);\n      yield new Promise(resolve => {\n        _this.onStopListening = resolve;\n      });\n    })();\n  }\n  getRecognition() {\n    return this.recognition;\n  }\n  start() {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      if (_this.recognition && !_this.listening) {\n        yield _this.recognition.start();\n        _this.listening = true;\n      }\n    })();\n  }\n  stop() {\n    if (this.recognition && this.listening) {\n      this.recognition.stop();\n      this.listening = false;\n    }\n  }\n  abort() {\n    if (this.recognition && this.listening) {\n      this.recognition.abort();\n      this.listening = false;\n    }\n  }\n  constructor(SpeechRecognition) {\n    this.recognition = null;\n    this.pauseAfterDisconnect = false;\n    this.interimTranscript = \"\";\n    this.finalTranscript = \"\";\n    this.listening = false;\n    this.isMicrophoneAvailable = true;\n    this.subscribers = {};\n    this.onStopListening = () => {};\n    this.previousResultWasFinalOnly = false;\n    this.resetTranscript = this.resetTranscript.bind(this);\n    this.startListening = this.startListening.bind(this);\n    this.stopListening = this.stopListening.bind(this);\n    this.abortListening = this.abortListening.bind(this);\n    this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\n    this.disableRecognition = this.disableRecognition.bind(this);\n    this.setSpeechRecognition(SpeechRecognition);\n    if (isAndroid()) {\n      this.updateFinalTranscript = debounce(this.updateFinalTranscript, 250);\n    }\n  }\n}\nconst CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\nconst APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\nconst clearTranscript = () => {\n  return {\n    type: CLEAR_TRANSCRIPT\n  };\n};\nconst appendTranscript = (interimTranscript, finalTranscript) => {\n  return {\n    type: APPEND_TRANSCRIPT,\n    payload: {\n      interimTranscript,\n      finalTranscript\n    }\n  };\n};\nconst transcriptReducer = (state, action) => {\n  switch (action.type) {\n    case CLEAR_TRANSCRIPT:\n      return {\n        interimTranscript: \"\",\n        finalTranscript: \"\"\n      };\n    case APPEND_TRANSCRIPT:\n      return {\n        interimTranscript: action.payload.interimTranscript,\n        finalTranscript: concatTranscripts(state.finalTranscript, action.payload.finalTranscript)\n      };\n    default:\n      throw new Error();\n  }\n};\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _async_to_generator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nlet _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\nlet _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\nlet recognitionManager;\nconst useSpeechRecognition = ({\n  transcribing = true,\n  clearTranscriptOnListen = true,\n  commands = []\n} = {}) => {\n  const [recognitionManager] = useState(SpeechRecognition.getRecognitionManager());\n  const [browserSupportsSpeechRecognition, setBrowserSupportsSpeechRecognition] = useState(_browserSupportsSpeechRecognition);\n  const [browserSupportsContinuousListening, setBrowserSupportsContinuousListening] = useState(_browserSupportsContinuousListening);\n  const [{\n    interimTranscript,\n    finalTranscript\n  }, dispatch] = useReducer(transcriptReducer, {\n    interimTranscript: recognitionManager.interimTranscript,\n    finalTranscript: \"\"\n  });\n  const [listening, setListening] = useState(recognitionManager.listening);\n  const [isMicrophoneAvailable, setMicrophoneAvailable] = useState(recognitionManager.isMicrophoneAvailable);\n  const commandsRef = useRef(commands);\n  commandsRef.current = commands;\n  const dispatchClearTranscript = () => {\n    dispatch(clearTranscript());\n  };\n  const resetTranscript = useCallback(() => {\n    recognitionManager.resetTranscript();\n    dispatchClearTranscript();\n  }, [recognitionManager]);\n  const testFuzzyMatch = (command, input, fuzzyMatchingThreshold) => {\n    const commandToString = typeof command === \"object\" ? command.toString() : command;\n    const commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\n    const howSimilar = compareTwoStringsUsingDiceCoefficient(commandWithoutSpecials, input);\n    if (howSimilar >= fuzzyMatchingThreshold) {\n      return {\n        command,\n        commandWithoutSpecials,\n        howSimilar,\n        isFuzzyMatch: true\n      };\n    }\n    return null;\n  };\n  const testMatch = (command, input) => {\n    const pattern = commandToRegExp(command);\n    const result = pattern.exec(input);\n    if (result) {\n      return {\n        command,\n        parameters: result.slice(1)\n      };\n    }\n    return null;\n  };\n  const matchCommands = useCallback((newInterimTranscript, newFinalTranscript) => {\n    commandsRef.current.forEach(({\n      command,\n      callback,\n      matchInterim = false,\n      isFuzzyMatch = false,\n      fuzzyMatchingThreshold = 0.8,\n      bestMatchOnly = false\n    }) => {\n      const input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\n      const subcommands = Array.isArray(command) ? command : [command];\n      const results = subcommands.map(subcommand => {\n        if (isFuzzyMatch) {\n          return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\n        }\n        return testMatch(subcommand, input);\n      }).filter(x => x);\n      if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\n        results.sort((a, b) => b.howSimilar - a.howSimilar);\n        const {\n          command,\n          commandWithoutSpecials,\n          howSimilar\n        } = results[0];\n        callback(commandWithoutSpecials, input, howSimilar, {\n          command,\n          resetTranscript\n        });\n      } else {\n        results.forEach(result => {\n          if (result.isFuzzyMatch) {\n            const {\n              command,\n              commandWithoutSpecials,\n              howSimilar\n            } = result;\n            callback(commandWithoutSpecials, input, howSimilar, {\n              command,\n              resetTranscript\n            });\n          } else {\n            const {\n              command,\n              parameters\n            } = result;\n            callback(...parameters, {\n              command,\n              resetTranscript\n            });\n          }\n        });\n      }\n    });\n  }, [resetTranscript]);\n  const handleTranscriptChange = useCallback((newInterimTranscript, newFinalTranscript) => {\n    if (transcribing) {\n      dispatch(appendTranscript(newInterimTranscript, newFinalTranscript));\n    }\n    matchCommands(newInterimTranscript, newFinalTranscript);\n  }, [matchCommands, transcribing]);\n  const handleClearTranscript = useCallback(() => {\n    if (clearTranscriptOnListen) {\n      dispatchClearTranscript();\n    }\n  }, [clearTranscriptOnListen]);\n  useEffect(() => {\n    const id = SpeechRecognition.counter;\n    SpeechRecognition.counter += 1;\n    const callbacks = {\n      onListeningChange: setListening,\n      onMicrophoneAvailabilityChange: setMicrophoneAvailable,\n      onTranscriptChange: handleTranscriptChange,\n      onClearTranscript: handleClearTranscript,\n      onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\n      onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\n    };\n    recognitionManager.subscribe(id, callbacks);\n    return () => {\n      recognitionManager.unsubscribe(id);\n    };\n  }, [transcribing, clearTranscriptOnListen, recognitionManager, handleTranscriptChange, handleClearTranscript]);\n  const transcript = concatTranscripts(finalTranscript, interimTranscript);\n  return {\n    transcript,\n    interimTranscript,\n    finalTranscript,\n    listening,\n    isMicrophoneAvailable,\n    resetTranscript,\n    browserSupportsSpeechRecognition,\n    browserSupportsContinuousListening\n  };\n};\nconst SpeechRecognition = {\n  counter: 0,\n  applyPolyfill: PolyfillSpeechRecognition => {\n    if (recognitionManager) {\n      recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\n    } else {\n      recognitionManager = new RecognitionManager(PolyfillSpeechRecognition);\n    }\n    const browserSupportsPolyfill = !!PolyfillSpeechRecognition && browserSupportsPolyfills();\n    _browserSupportsSpeechRecognition = browserSupportsPolyfill;\n    _browserSupportsContinuousListening = browserSupportsPolyfill;\n  },\n  removePolyfill: () => {\n    if (recognitionManager) {\n      recognitionManager.setSpeechRecognition(NativeSpeechRecognition);\n    } else {\n      recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n    }\n    _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\n    _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\n  },\n  getRecognitionManager: () => {\n    if (!recognitionManager) {\n      recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n    }\n    return recognitionManager;\n  },\n  getRecognition: () => {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    return recognitionManager.getRecognition();\n  },\n  startListening: /*#__PURE__*/_async_to_generator(function* ({\n    continuous,\n    language\n  } = {}) {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.startListening({\n      continuous,\n      language\n    });\n  }),\n  stopListening: /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.stopListening();\n  }),\n  abortListening: /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.abortListening();\n  }),\n  browserSupportsSpeechRecognition: () => _browserSupportsSpeechRecognition,\n  browserSupportsContinuousListening: () => _browserSupportsContinuousListening\n};\nexport { SpeechRecognition as default, useSpeechRecognition };","map":{"version":3,"names":["useState","useReducer","useRef","useCallback","useEffect","NativeSpeechRecognition","window","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","isNative","isAndroid","test","navigator","userAgent","debounce","func","wait","immediate","timeout","context","args","arguments","later","callNow","clearTimeout","setTimeout","apply","concatTranscripts","transcriptParts","map","t","trim","join","optionalParam","optionalRegex","namedParam","splatParam","escapeRegExp","commandToRegExp","command","RegExp","source","replace","match","optional","compareTwoStringsUsingDiceCoefficient","first","second","toLowerCase","length","firstBigrams","Map","i","bigram","substring","count","has","get","set","intersectionSize","browserSupportsPolyfills","undefined","mediaDevices","getUserMedia","AudioContext","webkitAudioContext","asyncGeneratorStep$1","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_async_to_generator$1","fn","self","err","RecognitionManager","setSpeechRecognition","browserSupportsRecogniser","disableRecognition","recognition","continuous","interimResults","onresult","updateTranscript","bind","onend","onRecognitionDisconnect","onerror","onError","emitBrowserSupportsSpeechRecognitionChange","subscribe","id","callbacks","subscribers","unsubscribe","emitListeningChange","listening","Object","keys","forEach","onListeningChange","emitMicrophoneAvailabilityChange","isMicrophoneAvailable","onMicrophoneAvailabilityChange","emitTranscriptChange","interimTranscript","finalTranscript","onTranscriptChange","emitClearTranscript","onClearTranscript","browserSupportsSpeechRecognitionChange","onBrowserSupportsSpeechRecognitionChange","onBrowserSupportsContinuousListeningChange","disconnect","disconnectType","pauseAfterDisconnect","abort","stop","stopListening","event","onStopListening","startListening","results","resultIndex","currentIndex","isFinal","confidence","updateFinalTranscript","transcript","isDuplicateResult","previousResultWasFinalOnly","newFinalTranscript","resetTranscript","language","_this","isContinuousChanged","isLanguageChanged","lang","start","e","DOMException","abortListening","getRecognition","constructor","CLEAR_TRANSCRIPT","APPEND_TRANSCRIPT","clearTranscript","type","appendTranscript","payload","transcriptReducer","state","action","Error","asyncGeneratorStep","_async_to_generator","_browserSupportsSpeechRecognition","_browserSupportsContinuousListening","recognitionManager","useSpeechRecognition","transcribing","clearTranscriptOnListen","commands","getRecognitionManager","browserSupportsSpeechRecognition","setBrowserSupportsSpeechRecognition","browserSupportsContinuousListening","setBrowserSupportsContinuousListening","dispatch","setListening","setMicrophoneAvailable","commandsRef","current","dispatchClearTranscript","testFuzzyMatch","input","fuzzyMatchingThreshold","commandToString","toString","commandWithoutSpecials","howSimilar","isFuzzyMatch","testMatch","pattern","result","exec","parameters","slice","matchCommands","newInterimTranscript","callback","matchInterim","bestMatchOnly","subcommands","Array","isArray","subcommand","filter","x","sort","a","b","handleTranscriptChange","handleClearTranscript","counter","applyPolyfill","PolyfillSpeechRecognition","browserSupportsPolyfill","removePolyfill","default"],"sources":["C:/Users/singh/OneDrive/Desktop/A_CIPHER/bot/frontend/node_modules/react-speech-recognition/dist/index.js"],"sourcesContent":["import { useState, useReducer, useRef, useCallback, useEffect } from 'react';\n\nconst NativeSpeechRecognition = typeof window !== \"undefined\" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\nconst isNative = (SpeechRecognition)=>SpeechRecognition === NativeSpeechRecognition;\n\nvar isAndroid = (()=>/(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\"));\n\nconst debounce = (func, wait, immediate)=>{\n    let timeout;\n    return function() {\n        const context = this;\n        const args = arguments;\n        const later = function() {\n            timeout = null;\n        };\n        const callNow = !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n};\nconst concatTranscripts = (...transcriptParts)=>{\n    return transcriptParts.map((t)=>t.trim()).join(\" \").trim();\n};\n// The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\nconst optionalParam = /\\s*\\((.*?)\\)\\s*/g;\nconst optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\nconst namedParam = /(\\(\\?)?:\\w+/g;\nconst splatParam = /\\*/g;\nconst escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\nconst commandToRegExp = (command)=>{\n    if (command instanceof RegExp) {\n        return new RegExp(command.source, \"i\");\n    }\n    command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, (match, optional)=>{\n        return optional ? match : \"([^\\\\s]+)\";\n    }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n    return new RegExp(\"^\" + command + \"$\", \"i\");\n};\n// this is from https://github.com/aceakash/string-similarity\nconst compareTwoStringsUsingDiceCoefficient = (first, second)=>{\n    first = first.replace(/\\s+/g, \"\").toLowerCase();\n    second = second.replace(/\\s+/g, \"\").toLowerCase();\n    if (!first.length && !second.length) return 1; // if both are empty strings\n    if (!first.length || !second.length) return 0; // if only one is empty string\n    if (first === second) return 1; // identical\n    if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\n    if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\n    const firstBigrams = new Map();\n    for(let i = 0; i < first.length - 1; i++){\n        const bigram = first.substring(i, i + 2);\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n        firstBigrams.set(bigram, count);\n    }\n    let intersectionSize = 0;\n    for(let i = 0; i < second.length - 1; i++){\n        const bigram = second.substring(i, i + 2);\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n        if (count > 0) {\n            firstBigrams.set(bigram, count - 1);\n            intersectionSize++;\n        }\n    }\n    return 2.0 * intersectionSize / (first.length + second.length - 2);\n};\nconst browserSupportsPolyfills = ()=>{\n    return typeof window !== \"undefined\" && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\n};\n\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator$1(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nclass RecognitionManager {\n    setSpeechRecognition(SpeechRecognition) {\n        const browserSupportsRecogniser = !!SpeechRecognition && (isNative(SpeechRecognition) || browserSupportsPolyfills());\n        if (browserSupportsRecogniser) {\n            this.disableRecognition();\n            this.recognition = new SpeechRecognition();\n            this.recognition.continuous = false;\n            this.recognition.interimResults = true;\n            this.recognition.onresult = this.updateTranscript.bind(this);\n            this.recognition.onend = this.onRecognitionDisconnect.bind(this);\n            this.recognition.onerror = this.onError.bind(this);\n        }\n        this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\n    }\n    subscribe(id, callbacks) {\n        this.subscribers[id] = callbacks;\n    }\n    unsubscribe(id) {\n        delete this.subscribers[id];\n    }\n    emitListeningChange(listening) {\n        this.listening = listening;\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onListeningChange } = this.subscribers[id];\n            onListeningChange(listening);\n        });\n    }\n    emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\n        this.isMicrophoneAvailable = isMicrophoneAvailable;\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onMicrophoneAvailabilityChange } = this.subscribers[id];\n            onMicrophoneAvailabilityChange(isMicrophoneAvailable);\n        });\n    }\n    emitTranscriptChange(interimTranscript, finalTranscript) {\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onTranscriptChange } = this.subscribers[id];\n            onTranscriptChange(interimTranscript, finalTranscript);\n        });\n    }\n    emitClearTranscript() {\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onClearTranscript } = this.subscribers[id];\n            onClearTranscript();\n        });\n    }\n    emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\n        Object.keys(this.subscribers).forEach((id)=>{\n            const { onBrowserSupportsSpeechRecognitionChange, onBrowserSupportsContinuousListeningChange } = this.subscribers[id];\n            onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\n            onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\n        });\n    }\n    disconnect(disconnectType) {\n        if (this.recognition && this.listening) {\n            switch(disconnectType){\n                case \"ABORT\":\n                    this.pauseAfterDisconnect = true;\n                    this.abort();\n                    break;\n                case \"RESET\":\n                    this.pauseAfterDisconnect = false;\n                    this.abort();\n                    break;\n                case \"STOP\":\n                default:\n                    this.pauseAfterDisconnect = true;\n                    this.stop();\n            }\n        }\n    }\n    disableRecognition() {\n        if (this.recognition) {\n            this.recognition.onresult = ()=>{};\n            this.recognition.onend = ()=>{};\n            this.recognition.onerror = ()=>{};\n            if (this.listening) {\n                this.stopListening();\n            }\n        }\n    }\n    onError(event) {\n        if (event && event.error && event.error === \"not-allowed\") {\n            this.emitMicrophoneAvailabilityChange(false);\n            this.disableRecognition();\n        }\n    }\n    onRecognitionDisconnect() {\n        this.onStopListening();\n        this.listening = false;\n        if (this.pauseAfterDisconnect) {\n            this.emitListeningChange(false);\n        } else if (this.recognition) {\n            if (this.recognition.continuous) {\n                this.startListening({\n                    continuous: this.recognition.continuous\n                });\n            } else {\n                this.emitListeningChange(false);\n            }\n        }\n        this.pauseAfterDisconnect = false;\n    }\n    updateTranscript({ results, resultIndex }) {\n        const currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\n        this.interimTranscript = \"\";\n        this.finalTranscript = \"\";\n        for(let i = currentIndex; i < results.length; ++i){\n            if (results[i].isFinal && (!isAndroid() || results[i][0].confidence > 0)) {\n                this.updateFinalTranscript(results[i][0].transcript);\n            } else {\n                this.interimTranscript = concatTranscripts(this.interimTranscript, results[i][0].transcript);\n            }\n        }\n        let isDuplicateResult = false;\n        if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\n            if (this.previousResultWasFinalOnly) {\n                isDuplicateResult = true;\n            }\n            this.previousResultWasFinalOnly = true;\n        } else {\n            this.previousResultWasFinalOnly = false;\n        }\n        if (!isDuplicateResult) {\n            this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\n        }\n    }\n    updateFinalTranscript(newFinalTranscript) {\n        this.finalTranscript = concatTranscripts(this.finalTranscript, newFinalTranscript);\n    }\n    resetTranscript() {\n        this.disconnect(\"RESET\");\n    }\n    startListening({ continuous = false, language } = {}) {\n        var _this = this;\n        return _async_to_generator$1(function*() {\n            if (!_this.recognition) {\n                return;\n            }\n            const isContinuousChanged = continuous !== _this.recognition.continuous;\n            const isLanguageChanged = language && language !== _this.recognition.lang;\n            if (isContinuousChanged || isLanguageChanged) {\n                if (_this.listening) {\n                    yield _this.stopListening();\n                }\n                _this.recognition.continuous = isContinuousChanged ? continuous : _this.recognition.continuous;\n                _this.recognition.lang = isLanguageChanged ? language : _this.recognition.lang;\n            }\n            if (!_this.listening) {\n                if (!_this.recognition.continuous) {\n                    _this.resetTranscript();\n                    _this.emitClearTranscript();\n                }\n                try {\n                    yield _this.start();\n                    _this.emitListeningChange(true);\n                } catch (e) {\n                    // DOMExceptions indicate a redundant microphone start - safe to swallow\n                    if (!(e instanceof DOMException)) {\n                        _this.emitMicrophoneAvailabilityChange(false);\n                    }\n                }\n            }\n        })();\n    }\n    abortListening() {\n        var _this = this;\n        return _async_to_generator$1(function*() {\n            _this.disconnect(\"ABORT\");\n            _this.emitListeningChange(false);\n            yield new Promise((resolve)=>{\n                _this.onStopListening = resolve;\n            });\n        })();\n    }\n    stopListening() {\n        var _this = this;\n        return _async_to_generator$1(function*() {\n            _this.disconnect(\"STOP\");\n            _this.emitListeningChange(false);\n            yield new Promise((resolve)=>{\n                _this.onStopListening = resolve;\n            });\n        })();\n    }\n    getRecognition() {\n        return this.recognition;\n    }\n    start() {\n        var _this = this;\n        return _async_to_generator$1(function*() {\n            if (_this.recognition && !_this.listening) {\n                yield _this.recognition.start();\n                _this.listening = true;\n            }\n        })();\n    }\n    stop() {\n        if (this.recognition && this.listening) {\n            this.recognition.stop();\n            this.listening = false;\n        }\n    }\n    abort() {\n        if (this.recognition && this.listening) {\n            this.recognition.abort();\n            this.listening = false;\n        }\n    }\n    constructor(SpeechRecognition){\n        this.recognition = null;\n        this.pauseAfterDisconnect = false;\n        this.interimTranscript = \"\";\n        this.finalTranscript = \"\";\n        this.listening = false;\n        this.isMicrophoneAvailable = true;\n        this.subscribers = {};\n        this.onStopListening = ()=>{};\n        this.previousResultWasFinalOnly = false;\n        this.resetTranscript = this.resetTranscript.bind(this);\n        this.startListening = this.startListening.bind(this);\n        this.stopListening = this.stopListening.bind(this);\n        this.abortListening = this.abortListening.bind(this);\n        this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\n        this.disableRecognition = this.disableRecognition.bind(this);\n        this.setSpeechRecognition(SpeechRecognition);\n        if (isAndroid()) {\n            this.updateFinalTranscript = debounce(this.updateFinalTranscript, 250);\n        }\n    }\n}\n\nconst CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\nconst APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\n\nconst clearTranscript = ()=>{\n    return {\n        type: CLEAR_TRANSCRIPT\n    };\n};\nconst appendTranscript = (interimTranscript, finalTranscript)=>{\n    return {\n        type: APPEND_TRANSCRIPT,\n        payload: {\n            interimTranscript,\n            finalTranscript\n        }\n    };\n};\n\nconst transcriptReducer = (state, action)=>{\n    switch(action.type){\n        case CLEAR_TRANSCRIPT:\n            return {\n                interimTranscript: \"\",\n                finalTranscript: \"\"\n            };\n        case APPEND_TRANSCRIPT:\n            return {\n                interimTranscript: action.payload.interimTranscript,\n                finalTranscript: concatTranscripts(state.finalTranscript, action.payload.finalTranscript)\n            };\n        default:\n            throw new Error();\n    }\n};\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nlet _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\nlet _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\nlet recognitionManager;\nconst useSpeechRecognition = ({ transcribing = true, clearTranscriptOnListen = true, commands = [] } = {})=>{\n    const [recognitionManager] = useState(SpeechRecognition.getRecognitionManager());\n    const [browserSupportsSpeechRecognition, setBrowserSupportsSpeechRecognition] = useState(_browserSupportsSpeechRecognition);\n    const [browserSupportsContinuousListening, setBrowserSupportsContinuousListening] = useState(_browserSupportsContinuousListening);\n    const [{ interimTranscript, finalTranscript }, dispatch] = useReducer(transcriptReducer, {\n        interimTranscript: recognitionManager.interimTranscript,\n        finalTranscript: \"\"\n    });\n    const [listening, setListening] = useState(recognitionManager.listening);\n    const [isMicrophoneAvailable, setMicrophoneAvailable] = useState(recognitionManager.isMicrophoneAvailable);\n    const commandsRef = useRef(commands);\n    commandsRef.current = commands;\n    const dispatchClearTranscript = ()=>{\n        dispatch(clearTranscript());\n    };\n    const resetTranscript = useCallback(()=>{\n        recognitionManager.resetTranscript();\n        dispatchClearTranscript();\n    }, [\n        recognitionManager\n    ]);\n    const testFuzzyMatch = (command, input, fuzzyMatchingThreshold)=>{\n        const commandToString = typeof command === \"object\" ? command.toString() : command;\n        const commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\n        const howSimilar = compareTwoStringsUsingDiceCoefficient(commandWithoutSpecials, input);\n        if (howSimilar >= fuzzyMatchingThreshold) {\n            return {\n                command,\n                commandWithoutSpecials,\n                howSimilar,\n                isFuzzyMatch: true\n            };\n        }\n        return null;\n    };\n    const testMatch = (command, input)=>{\n        const pattern = commandToRegExp(command);\n        const result = pattern.exec(input);\n        if (result) {\n            return {\n                command,\n                parameters: result.slice(1)\n            };\n        }\n        return null;\n    };\n    const matchCommands = useCallback((newInterimTranscript, newFinalTranscript)=>{\n        commandsRef.current.forEach(({ command, callback, matchInterim = false, isFuzzyMatch = false, fuzzyMatchingThreshold = 0.8, bestMatchOnly = false })=>{\n            const input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\n            const subcommands = Array.isArray(command) ? command : [\n                command\n            ];\n            const results = subcommands.map((subcommand)=>{\n                if (isFuzzyMatch) {\n                    return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\n                }\n                return testMatch(subcommand, input);\n            }).filter((x)=>x);\n            if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\n                results.sort((a, b)=>b.howSimilar - a.howSimilar);\n                const { command, commandWithoutSpecials, howSimilar } = results[0];\n                callback(commandWithoutSpecials, input, howSimilar, {\n                    command,\n                    resetTranscript\n                });\n            } else {\n                results.forEach((result)=>{\n                    if (result.isFuzzyMatch) {\n                        const { command, commandWithoutSpecials, howSimilar } = result;\n                        callback(commandWithoutSpecials, input, howSimilar, {\n                            command,\n                            resetTranscript\n                        });\n                    } else {\n                        const { command, parameters } = result;\n                        callback(...parameters, {\n                            command,\n                            resetTranscript\n                        });\n                    }\n                });\n            }\n        });\n    }, [\n        resetTranscript\n    ]);\n    const handleTranscriptChange = useCallback((newInterimTranscript, newFinalTranscript)=>{\n        if (transcribing) {\n            dispatch(appendTranscript(newInterimTranscript, newFinalTranscript));\n        }\n        matchCommands(newInterimTranscript, newFinalTranscript);\n    }, [\n        matchCommands,\n        transcribing\n    ]);\n    const handleClearTranscript = useCallback(()=>{\n        if (clearTranscriptOnListen) {\n            dispatchClearTranscript();\n        }\n    }, [\n        clearTranscriptOnListen\n    ]);\n    useEffect(()=>{\n        const id = SpeechRecognition.counter;\n        SpeechRecognition.counter += 1;\n        const callbacks = {\n            onListeningChange: setListening,\n            onMicrophoneAvailabilityChange: setMicrophoneAvailable,\n            onTranscriptChange: handleTranscriptChange,\n            onClearTranscript: handleClearTranscript,\n            onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\n            onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\n        };\n        recognitionManager.subscribe(id, callbacks);\n        return ()=>{\n            recognitionManager.unsubscribe(id);\n        };\n    }, [\n        transcribing,\n        clearTranscriptOnListen,\n        recognitionManager,\n        handleTranscriptChange,\n        handleClearTranscript\n    ]);\n    const transcript = concatTranscripts(finalTranscript, interimTranscript);\n    return {\n        transcript,\n        interimTranscript,\n        finalTranscript,\n        listening,\n        isMicrophoneAvailable,\n        resetTranscript,\n        browserSupportsSpeechRecognition,\n        browserSupportsContinuousListening\n    };\n};\nconst SpeechRecognition = {\n    counter: 0,\n    applyPolyfill: (PolyfillSpeechRecognition)=>{\n        if (recognitionManager) {\n            recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\n        } else {\n            recognitionManager = new RecognitionManager(PolyfillSpeechRecognition);\n        }\n        const browserSupportsPolyfill = !!PolyfillSpeechRecognition && browserSupportsPolyfills();\n        _browserSupportsSpeechRecognition = browserSupportsPolyfill;\n        _browserSupportsContinuousListening = browserSupportsPolyfill;\n    },\n    removePolyfill: ()=>{\n        if (recognitionManager) {\n            recognitionManager.setSpeechRecognition(NativeSpeechRecognition);\n        } else {\n            recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n        }\n        _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\n        _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\n    },\n    getRecognitionManager: ()=>{\n        if (!recognitionManager) {\n            recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n        }\n        return recognitionManager;\n    },\n    getRecognition: ()=>{\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\n        return recognitionManager.getRecognition();\n    },\n    startListening: /*#__PURE__*/ _async_to_generator(function*({ continuous, language } = {}) {\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\n        yield recognitionManager.startListening({\n            continuous,\n            language\n        });\n    }),\n    stopListening: /*#__PURE__*/ _async_to_generator(function*() {\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\n        yield recognitionManager.stopListening();\n    }),\n    abortListening: /*#__PURE__*/ _async_to_generator(function*() {\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\n        yield recognitionManager.abortListening();\n    }),\n    browserSupportsSpeechRecognition: ()=>_browserSupportsSpeechRecognition,\n    browserSupportsContinuousListening: ()=>_browserSupportsContinuousListening\n};\n\nexport { SpeechRecognition as default, useSpeechRecognition };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}