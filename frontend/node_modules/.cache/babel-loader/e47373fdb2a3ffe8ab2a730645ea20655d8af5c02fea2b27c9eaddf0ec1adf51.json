{"ast":null,"code":"import { useState, useReducer, useRef, useCallback, useEffect } from 'react';\nconst NativeSpeechRecognition = typeof window !== \"undefined\" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\nconst isNative = SpeechRecognition => SpeechRecognition === NativeSpeechRecognition;\nvar isAndroid = () => /(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\");\nconst debounce = (func, wait, immediate) => {\n  let timeout;\n  return function () {\n    const context = this;\n    const args = arguments;\n    const later = function () {\n      timeout = null;\n    };\n    const callNow = !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};\nconst concatTranscripts = (...transcriptParts) => {\n  return transcriptParts.map(t => t.trim()).join(\" \").trim();\n};\n// The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\nconst optionalParam = /\\s*\\((.*?)\\)\\s*/g;\nconst optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\nconst namedParam = /(\\(\\?)?:\\w+/g;\nconst splatParam = /\\*/g;\nconst escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\nconst commandToRegExp = command => {\n  if (command instanceof RegExp) {\n    return new RegExp(command.source, \"i\");\n  }\n  command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, (match, optional) => {\n    return optional ? match : \"([^\\\\s]+)\";\n  }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n  return new RegExp(\"^\" + command + \"$\", \"i\");\n};\n// this is from https://github.com/aceakash/string-similarity\nconst compareTwoStringsUsingDiceCoefficient = (first, second) => {\n  first = first.replace(/\\s+/g, \"\").toLowerCase();\n  second = second.replace(/\\s+/g, \"\").toLowerCase();\n  if (!first.length && !second.length) return 1; // if both are empty strings\n  if (!first.length || !second.length) return 0; // if only one is empty string\n  if (first === second) return 1; // identical\n  if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\n  if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\n  const firstBigrams = new Map();\n  for (let i = 0; i < first.length - 1; i++) {\n    const bigram = first.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n    firstBigrams.set(bigram, count);\n  }\n  let intersectionSize = 0;\n  for (let i = 0; i < second.length - 1; i++) {\n    const bigram = second.substring(i, i + 2);\n    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n    if (count > 0) {\n      firstBigrams.set(bigram, count - 1);\n      intersectionSize++;\n    }\n  }\n  return 2.0 * intersectionSize / (first.length + second.length - 2);\n};\nconst browserSupportsPolyfills = () => {\n  return typeof window !== \"undefined\" && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\n};\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _async_to_generator$1(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nclass RecognitionManager {\n  setSpeechRecognition(SpeechRecognition) {\n    const browserSupportsRecogniser = !!SpeechRecognition && (isNative(SpeechRecognition) || browserSupportsPolyfills());\n    if (browserSupportsRecogniser) {\n      this.disableRecognition();\n      this.recognition = new SpeechRecognition();\n      this.recognition.continuous = false;\n      this.recognition.interimResults = true;\n      this.recognition.onresult = this.updateTranscript.bind(this);\n      this.recognition.onend = this.onRecognitionDisconnect.bind(this);\n      this.recognition.onerror = this.onError.bind(this);\n    }\n    this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\n  }\n  subscribe(id, callbacks) {\n    this.subscribers[id] = callbacks;\n  }\n  unsubscribe(id) {\n    delete this.subscribers[id];\n  }\n  emitListeningChange(listening) {\n    this.listening = listening;\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onListeningChange\n      } = this.subscribers[id];\n      onListeningChange(listening);\n    });\n  }\n  emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\n    this.isMicrophoneAvailable = isMicrophoneAvailable;\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onMicrophoneAvailabilityChange\n      } = this.subscribers[id];\n      onMicrophoneAvailabilityChange(isMicrophoneAvailable);\n    });\n  }\n  emitTranscriptChange(interimTranscript, finalTranscript) {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onTranscriptChange\n      } = this.subscribers[id];\n      onTranscriptChange(interimTranscript, finalTranscript);\n    });\n  }\n  emitClearTranscript() {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onClearTranscript\n      } = this.subscribers[id];\n      onClearTranscript();\n    });\n  }\n  emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\n    Object.keys(this.subscribers).forEach(id => {\n      const {\n        onBrowserSupportsSpeechRecognitionChange,\n        onBrowserSupportsContinuousListeningChange\n      } = this.subscribers[id];\n      onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\n      onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\n    });\n  }\n  disconnect(disconnectType) {\n    if (this.recognition && this.listening) {\n      switch (disconnectType) {\n        case \"ABORT\":\n          this.pauseAfterDisconnect = true;\n          this.abort();\n          break;\n        case \"RESET\":\n          this.pauseAfterDisconnect = false;\n          this.abort();\n          break;\n        case \"STOP\":\n        default:\n          this.pauseAfterDisconnect = true;\n          this.stop();\n      }\n    }\n  }\n  disableRecognition() {\n    if (this.recognition) {\n      this.recognition.onresult = () => {};\n      this.recognition.onend = () => {};\n      this.recognition.onerror = () => {};\n      if (this.listening) {\n        this.stopListening();\n      }\n    }\n  }\n  onError(event) {\n    if (event && event.error && event.error === \"not-allowed\") {\n      this.emitMicrophoneAvailabilityChange(false);\n      this.disableRecognition();\n    }\n  }\n  onRecognitionDisconnect() {\n    this.onStopListening();\n    this.listening = false;\n    if (this.pauseAfterDisconnect) {\n      this.emitListeningChange(false);\n    } else if (this.recognition) {\n      if (this.recognition.continuous) {\n        this.startListening({\n          continuous: this.recognition.continuous\n        });\n      } else {\n        this.emitListeningChange(false);\n      }\n    }\n    this.pauseAfterDisconnect = false;\n  }\n  updateTranscript({\n    results,\n    resultIndex\n  }) {\n    const currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\n    this.interimTranscript = \"\";\n    this.finalTranscript = \"\";\n    for (let i = currentIndex; i < results.length; ++i) {\n      if (results[i].isFinal && (!isAndroid() || results[i][0].confidence > 0)) {\n        this.updateFinalTranscript(results[i][0].transcript);\n      } else {\n        this.interimTranscript = concatTranscripts(this.interimTranscript, results[i][0].transcript);\n      }\n    }\n    let isDuplicateResult = false;\n    if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\n      if (this.previousResultWasFinalOnly) {\n        isDuplicateResult = true;\n      }\n      this.previousResultWasFinalOnly = true;\n    } else {\n      this.previousResultWasFinalOnly = false;\n    }\n    if (!isDuplicateResult) {\n      this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\n    }\n  }\n  updateFinalTranscript(newFinalTranscript) {\n    this.finalTranscript = concatTranscripts(this.finalTranscript, newFinalTranscript);\n  }\n  resetTranscript() {\n    this.disconnect(\"RESET\");\n  }\n  startListening({\n    continuous = false,\n    language\n  } = {}) {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      if (!_this.recognition) {\n        return;\n      }\n      const isContinuousChanged = continuous !== _this.recognition.continuous;\n      const isLanguageChanged = language && language !== _this.recognition.lang;\n      if (isContinuousChanged || isLanguageChanged) {\n        if (_this.listening) {\n          yield _this.stopListening();\n        }\n        _this.recognition.continuous = isContinuousChanged ? continuous : _this.recognition.continuous;\n        _this.recognition.lang = isLanguageChanged ? language : _this.recognition.lang;\n      }\n      if (!_this.listening) {\n        if (!_this.recognition.continuous) {\n          _this.resetTranscript();\n          _this.emitClearTranscript();\n        }\n        try {\n          yield _this.start();\n          _this.emitListeningChange(true);\n        } catch (e) {\n          // DOMExceptions indicate a redundant microphone start - safe to swallow\n          if (!(e instanceof DOMException)) {\n            _this.emitMicrophoneAvailabilityChange(false);\n          }\n        }\n      }\n    })();\n  }\n  abortListening() {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      _this.disconnect(\"ABORT\");\n      _this.emitListeningChange(false);\n      yield new Promise(resolve => {\n        _this.onStopListening = resolve;\n      });\n    })();\n  }\n  stopListening() {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      _this.disconnect(\"STOP\");\n      _this.emitListeningChange(false);\n      yield new Promise(resolve => {\n        _this.onStopListening = resolve;\n      });\n    })();\n  }\n  getRecognition() {\n    return this.recognition;\n  }\n  start() {\n    var _this = this;\n    return _async_to_generator$1(function* () {\n      if (_this.recognition && !_this.listening) {\n        yield _this.recognition.start();\n        _this.listening = true;\n      }\n    })();\n  }\n  stop() {\n    if (this.recognition && this.listening) {\n      this.recognition.stop();\n      this.listening = false;\n    }\n  }\n  abort() {\n    if (this.recognition && this.listening) {\n      this.recognition.abort();\n      this.listening = false;\n    }\n  }\n  constructor(SpeechRecognition) {\n    this.recognition = null;\n    this.pauseAfterDisconnect = false;\n    this.interimTranscript = \"\";\n    this.finalTranscript = \"\";\n    this.listening = false;\n    this.isMicrophoneAvailable = true;\n    this.subscribers = {};\n    this.onStopListening = () => {};\n    this.previousResultWasFinalOnly = false;\n    this.resetTranscript = this.resetTranscript.bind(this);\n    this.startListening = this.startListening.bind(this);\n    this.stopListening = this.stopListening.bind(this);\n    this.abortListening = this.abortListening.bind(this);\n    this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\n    this.disableRecognition = this.disableRecognition.bind(this);\n    this.setSpeechRecognition(SpeechRecognition);\n    if (isAndroid()) {\n      this.updateFinalTranscript = debounce(this.updateFinalTranscript, 250);\n    }\n  }\n}\nconst CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\nconst APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\nconst clearTranscript = () => {\n  return {\n    type: CLEAR_TRANSCRIPT\n  };\n};\nconst appendTranscript = (interimTranscript, finalTranscript) => {\n  return {\n    type: APPEND_TRANSCRIPT,\n    payload: {\n      interimTranscript,\n      finalTranscript\n    }\n  };\n};\nconst transcriptReducer = (state, action) => {\n  switch (action.type) {\n    case CLEAR_TRANSCRIPT:\n      return {\n        interimTranscript: \"\",\n        finalTranscript: \"\"\n      };\n    case APPEND_TRANSCRIPT:\n      return {\n        interimTranscript: action.payload.interimTranscript,\n        finalTranscript: concatTranscripts(state.finalTranscript, action.payload.finalTranscript)\n      };\n    default:\n      throw new Error();\n  }\n};\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _async_to_generator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nlet _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\nlet _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\nlet recognitionManager;\nconst useSpeechRecognition = ({\n  transcribing = true,\n  clearTranscriptOnListen = true,\n  commands = []\n} = {}) => {\n  const [recognitionManager] = useState(SpeechRecognition.getRecognitionManager());\n  const [browserSupportsSpeechRecognition, setBrowserSupportsSpeechRecognition] = useState(_browserSupportsSpeechRecognition);\n  const [browserSupportsContinuousListening, setBrowserSupportsContinuousListening] = useState(_browserSupportsContinuousListening);\n  const [{\n    interimTranscript,\n    finalTranscript\n  }, dispatch] = useReducer(transcriptReducer, {\n    interimTranscript: recognitionManager.interimTranscript,\n    finalTranscript: \"\"\n  });\n  const [listening, setListening] = useState(recognitionManager.listening);\n  const [isMicrophoneAvailable, setMicrophoneAvailable] = useState(recognitionManager.isMicrophoneAvailable);\n  const commandsRef = useRef(commands);\n  commandsRef.current = commands;\n  const dispatchClearTranscript = () => {\n    dispatch(clearTranscript());\n  };\n  const resetTranscript = useCallback(() => {\n    recognitionManager.resetTranscript();\n    dispatchClearTranscript();\n  }, [recognitionManager]);\n  const testFuzzyMatch = (command, input, fuzzyMatchingThreshold) => {\n    const commandToString = typeof command === \"object\" ? command.toString() : command;\n    const commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\n    const howSimilar = compareTwoStringsUsingDiceCoefficient(commandWithoutSpecials, input);\n    if (howSimilar >= fuzzyMatchingThreshold) {\n      return {\n        command,\n        commandWithoutSpecials,\n        howSimilar,\n        isFuzzyMatch: true\n      };\n    }\n    return null;\n  };\n  const testMatch = (command, input) => {\n    const pattern = commandToRegExp(command);\n    const result = pattern.exec(input);\n    if (result) {\n      return {\n        command,\n        parameters: result.slice(1)\n      };\n    }\n    return null;\n  };\n  const matchCommands = useCallback((newInterimTranscript, newFinalTranscript) => {\n    commandsRef.current.forEach(({\n      command,\n      callback,\n      matchInterim = false,\n      isFuzzyMatch = false,\n      fuzzyMatchingThreshold = 0.8,\n      bestMatchOnly = false\n    }) => {\n      const input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\n      const subcommands = Array.isArray(command) ? command : [command];\n      const results = subcommands.map(subcommand => {\n        if (isFuzzyMatch) {\n          return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\n        }\n        return testMatch(subcommand, input);\n      }).filter(x => x);\n      if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\n        results.sort((a, b) => b.howSimilar - a.howSimilar);\n        const {\n          command,\n          commandWithoutSpecials,\n          howSimilar\n        } = results[0];\n        callback(commandWithoutSpecials, input, howSimilar, {\n          command,\n          resetTranscript\n        });\n      } else {\n        results.forEach(result => {\n          if (result.isFuzzyMatch) {\n            const {\n              command,\n              commandWithoutSpecials,\n              howSimilar\n            } = result;\n            callback(commandWithoutSpecials, input, howSimilar, {\n              command,\n              resetTranscript\n            });\n          } else {\n            const {\n              command,\n              parameters\n            } = result;\n            callback(...parameters, {\n              command,\n              resetTranscript\n            });\n          }\n        });\n      }\n    });\n  }, [resetTranscript]);\n  const handleTranscriptChange = useCallback((newInterimTranscript, newFinalTranscript) => {\n    if (transcribing) {\n      dispatch(appendTranscript(newInterimTranscript, newFinalTranscript));\n    }\n    matchCommands(newInterimTranscript, newFinalTranscript);\n  }, [matchCommands, transcribing]);\n  const handleClearTranscript = useCallback(() => {\n    if (clearTranscriptOnListen) {\n      dispatchClearTranscript();\n    }\n  }, [clearTranscriptOnListen]);\n  useEffect(() => {\n    const id = SpeechRecognition.counter;\n    SpeechRecognition.counter += 1;\n    const callbacks = {\n      onListeningChange: setListening,\n      onMicrophoneAvailabilityChange: setMicrophoneAvailable,\n      onTranscriptChange: handleTranscriptChange,\n      onClearTranscript: handleClearTranscript,\n      onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\n      onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\n    };\n    recognitionManager.subscribe(id, callbacks);\n    return () => {\n      recognitionManager.unsubscribe(id);\n    };\n  }, [transcribing, clearTranscriptOnListen, recognitionManager, handleTranscriptChange, handleClearTranscript]);\n  const transcript = concatTranscripts(finalTranscript, interimTranscript);\n  return {\n    transcript,\n    interimTranscript,\n    finalTranscript,\n    listening,\n    isMicrophoneAvailable,\n    resetTranscript,\n    browserSupportsSpeechRecognition,\n    browserSupportsContinuousListening\n  };\n};\nconst SpeechRecognition = {\n  counter: 0,\n  applyPolyfill: PolyfillSpeechRecognition => {\n    if (recognitionManager) {\n      recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\n    } else {\n      recognitionManager = new RecognitionManager(PolyfillSpeechRecognition);\n    }\n    const browserSupportsPolyfill = !!PolyfillSpeechRecognition && browserSupportsPolyfills();\n    _browserSupportsSpeechRecognition = browserSupportsPolyfill;\n    _browserSupportsContinuousListening = browserSupportsPolyfill;\n  },\n  removePolyfill: () => {\n    if (recognitionManager) {\n      recognitionManager.setSpeechRecognition(NativeSpeechRecognition);\n    } else {\n      recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n    }\n    _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\n    _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\n  },\n  getRecognitionManager: () => {\n    if (!recognitionManager) {\n      recognitionManager = new RecognitionManager(NativeSpeechRecognition);\n    }\n    return recognitionManager;\n  },\n  getRecognition: () => {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    return recognitionManager.getRecognition();\n  },\n  startListening: /*#__PURE__*/_async_to_generator(function* ({\n    continuous,\n    language\n  } = {}) {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.startListening({\n      continuous,\n      language\n    });\n  }),\n  stopListening: /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.stopListening();\n  }),\n  abortListening: /*#__PURE__*/_async_to_generator(function* () {\n    const recognitionManager = SpeechRecognition.getRecognitionManager();\n    yield recognitionManager.abortListening();\n  }),\n  browserSupportsSpeechRecognition: () => _browserSupportsSpeechRecognition,\n  browserSupportsContinuousListening: () => _browserSupportsContinuousListening\n};\nexport { SpeechRecognition as default, useSpeechRecognition };","map":{"version":3,"names":["useState","useReducer","useRef","useCallback","useEffect","NativeSpeechRecognition","window","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","isNative","isAndroid","test","navigator","userAgent","debounce","func","wait","immediate","timeout","context","args","arguments","later","callNow","clearTimeout","setTimeout","apply","concatTranscripts","transcriptParts","map","t","trim","join","optionalParam","optionalRegex","namedParam","splatParam","escapeRegExp","commandToRegExp","command","RegExp","source","replace","match","optional","compareTwoStringsUsingDiceCoefficient","first","second","toLowerCase","length","firstBigrams","Map","i","bigram","substring","count","has","get","set","intersectionSize","browserSupportsPolyfills","undefined","mediaDevices","getUserMedia","AudioContext","webkitAudioContext","asyncGeneratorStep$1","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_async_to_generator$1","fn","self","err","RecognitionManager","setSpeechRecognition","browserSupportsRecogniser","disableRecognition","recognition","continuous","interimResults","onresult","updateTranscript","bind","onend","onRecognitionDisconnect","onerror","onError","emitBrowserSupportsSpeechRecognitionChange","subscribe","id","callbacks","subscribers","unsubscribe","emitListeningChange","listening","Object","keys","forEach","onListeningChange","emitMicrophoneAvailabilityChange","isMicrophoneAvailable","onMicrophoneAvailabilityChange","emitTranscriptChange","interimTranscript","finalTranscript","onTranscriptChange","emitClearTranscript","onClearTranscript","browserSupportsSpeechRecognitionChange","onBrowserSupportsSpeechRecognitionChange","onBrowserSupportsContinuousListeningChange","disconnect","disconnectType","pauseAfterDisconnect","abort","stop","stopListening","event","onStopListening","startListening","results","resultIndex","currentIndex","isFinal","confidence","updateFinalTranscript","transcript","isDuplicateResult","previousResultWasFinalOnly","newFinalTranscript","resetTranscript","language","_this","isContinuousChanged","isLanguageChanged","lang","start","e","DOMException","abortListening","getRecognition","constructor","CLEAR_TRANSCRIPT","APPEND_TRANSCRIPT","clearTranscript","type","appendTranscript","payload","transcriptReducer","state","action","Error","asyncGeneratorStep","_async_to_generator","_browserSupportsSpeechRecognition","_browserSupportsContinuousListening","recognitionManager","useSpeechRecognition","transcribing","clearTranscriptOnListen","commands","getRecognitionManager","browserSupportsSpeechRecognition","setBrowserSupportsSpeechRecognition","browserSupportsContinuousListening","setBrowserSupportsContinuousListening","dispatch","setListening","setMicrophoneAvailable","commandsRef","current","dispatchClearTranscript","testFuzzyMatch","input","fuzzyMatchingThreshold","commandToString","toString","commandWithoutSpecials","howSimilar","isFuzzyMatch","testMatch","pattern","result","exec","parameters","slice","matchCommands","newInterimTranscript","callback","matchInterim","bestMatchOnly","subcommands","Array","isArray","subcommand","filter","x","sort","a","b","handleTranscriptChange","handleClearTranscript","counter","applyPolyfill","PolyfillSpeechRecognition","browserSupportsPolyfill","removePolyfill","default"],"sources":["C:/Users/singh/OneDrive/Desktop/A_CIPHER/bot/frontend/node_modules/react-speech-recognition/dist/index.js"],"sourcesContent":["import { useState, useReducer, useRef, useCallback, useEffect } from 'react';\r\n\r\nconst NativeSpeechRecognition = typeof window !== \"undefined\" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\r\nconst isNative = (SpeechRecognition)=>SpeechRecognition === NativeSpeechRecognition;\r\n\r\nvar isAndroid = (()=>/(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\"));\r\n\r\nconst debounce = (func, wait, immediate)=>{\r\n    let timeout;\r\n    return function() {\r\n        const context = this;\r\n        const args = arguments;\r\n        const later = function() {\r\n            timeout = null;\r\n        };\r\n        const callNow = !timeout;\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n        if (callNow) func.apply(context, args);\r\n    };\r\n};\r\nconst concatTranscripts = (...transcriptParts)=>{\r\n    return transcriptParts.map((t)=>t.trim()).join(\" \").trim();\r\n};\r\n// The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\r\nconst optionalParam = /\\s*\\((.*?)\\)\\s*/g;\r\nconst optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\r\nconst namedParam = /(\\(\\?)?:\\w+/g;\r\nconst splatParam = /\\*/g;\r\nconst escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\r\nconst commandToRegExp = (command)=>{\r\n    if (command instanceof RegExp) {\r\n        return new RegExp(command.source, \"i\");\r\n    }\r\n    command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, (match, optional)=>{\r\n        return optional ? match : \"([^\\\\s]+)\";\r\n    }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\r\n    return new RegExp(\"^\" + command + \"$\", \"i\");\r\n};\r\n// this is from https://github.com/aceakash/string-similarity\r\nconst compareTwoStringsUsingDiceCoefficient = (first, second)=>{\r\n    first = first.replace(/\\s+/g, \"\").toLowerCase();\r\n    second = second.replace(/\\s+/g, \"\").toLowerCase();\r\n    if (!first.length && !second.length) return 1; // if both are empty strings\r\n    if (!first.length || !second.length) return 0; // if only one is empty string\r\n    if (first === second) return 1; // identical\r\n    if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\r\n    if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\r\n    const firstBigrams = new Map();\r\n    for(let i = 0; i < first.length - 1; i++){\r\n        const bigram = first.substring(i, i + 2);\r\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\r\n        firstBigrams.set(bigram, count);\r\n    }\r\n    let intersectionSize = 0;\r\n    for(let i = 0; i < second.length - 1; i++){\r\n        const bigram = second.substring(i, i + 2);\r\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\r\n        if (count > 0) {\r\n            firstBigrams.set(bigram, count - 1);\r\n            intersectionSize++;\r\n        }\r\n    }\r\n    return 2.0 * intersectionSize / (first.length + second.length - 2);\r\n};\r\nconst browserSupportsPolyfills = ()=>{\r\n    return typeof window !== \"undefined\" && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\r\n};\r\n\r\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\r\n    try {\r\n        var info = gen[key](arg);\r\n        var value = info.value;\r\n    } catch (error) {\r\n        reject(error);\r\n        return;\r\n    }\r\n    if (info.done) {\r\n        resolve(value);\r\n    } else {\r\n        Promise.resolve(value).then(_next, _throw);\r\n    }\r\n}\r\nfunction _async_to_generator$1(fn) {\r\n    return function() {\r\n        var self = this, args = arguments;\r\n        return new Promise(function(resolve, reject) {\r\n            var gen = fn.apply(self, args);\r\n            function _next(value) {\r\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\r\n            }\r\n            function _throw(err) {\r\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\r\n            }\r\n            _next(undefined);\r\n        });\r\n    };\r\n}\r\nclass RecognitionManager {\r\n    setSpeechRecognition(SpeechRecognition) {\r\n        const browserSupportsRecogniser = !!SpeechRecognition && (isNative(SpeechRecognition) || browserSupportsPolyfills());\r\n        if (browserSupportsRecogniser) {\r\n            this.disableRecognition();\r\n            this.recognition = new SpeechRecognition();\r\n            this.recognition.continuous = false;\r\n            this.recognition.interimResults = true;\r\n            this.recognition.onresult = this.updateTranscript.bind(this);\r\n            this.recognition.onend = this.onRecognitionDisconnect.bind(this);\r\n            this.recognition.onerror = this.onError.bind(this);\r\n        }\r\n        this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\r\n    }\r\n    subscribe(id, callbacks) {\r\n        this.subscribers[id] = callbacks;\r\n    }\r\n    unsubscribe(id) {\r\n        delete this.subscribers[id];\r\n    }\r\n    emitListeningChange(listening) {\r\n        this.listening = listening;\r\n        Object.keys(this.subscribers).forEach((id)=>{\r\n            const { onListeningChange } = this.subscribers[id];\r\n            onListeningChange(listening);\r\n        });\r\n    }\r\n    emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\r\n        this.isMicrophoneAvailable = isMicrophoneAvailable;\r\n        Object.keys(this.subscribers).forEach((id)=>{\r\n            const { onMicrophoneAvailabilityChange } = this.subscribers[id];\r\n            onMicrophoneAvailabilityChange(isMicrophoneAvailable);\r\n        });\r\n    }\r\n    emitTranscriptChange(interimTranscript, finalTranscript) {\r\n        Object.keys(this.subscribers).forEach((id)=>{\r\n            const { onTranscriptChange } = this.subscribers[id];\r\n            onTranscriptChange(interimTranscript, finalTranscript);\r\n        });\r\n    }\r\n    emitClearTranscript() {\r\n        Object.keys(this.subscribers).forEach((id)=>{\r\n            const { onClearTranscript } = this.subscribers[id];\r\n            onClearTranscript();\r\n        });\r\n    }\r\n    emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\r\n        Object.keys(this.subscribers).forEach((id)=>{\r\n            const { onBrowserSupportsSpeechRecognitionChange, onBrowserSupportsContinuousListeningChange } = this.subscribers[id];\r\n            onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\r\n            onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\r\n        });\r\n    }\r\n    disconnect(disconnectType) {\r\n        if (this.recognition && this.listening) {\r\n            switch(disconnectType){\r\n                case \"ABORT\":\r\n                    this.pauseAfterDisconnect = true;\r\n                    this.abort();\r\n                    break;\r\n                case \"RESET\":\r\n                    this.pauseAfterDisconnect = false;\r\n                    this.abort();\r\n                    break;\r\n                case \"STOP\":\r\n                default:\r\n                    this.pauseAfterDisconnect = true;\r\n                    this.stop();\r\n            }\r\n        }\r\n    }\r\n    disableRecognition() {\r\n        if (this.recognition) {\r\n            this.recognition.onresult = ()=>{};\r\n            this.recognition.onend = ()=>{};\r\n            this.recognition.onerror = ()=>{};\r\n            if (this.listening) {\r\n                this.stopListening();\r\n            }\r\n        }\r\n    }\r\n    onError(event) {\r\n        if (event && event.error && event.error === \"not-allowed\") {\r\n            this.emitMicrophoneAvailabilityChange(false);\r\n            this.disableRecognition();\r\n        }\r\n    }\r\n    onRecognitionDisconnect() {\r\n        this.onStopListening();\r\n        this.listening = false;\r\n        if (this.pauseAfterDisconnect) {\r\n            this.emitListeningChange(false);\r\n        } else if (this.recognition) {\r\n            if (this.recognition.continuous) {\r\n                this.startListening({\r\n                    continuous: this.recognition.continuous\r\n                });\r\n            } else {\r\n                this.emitListeningChange(false);\r\n            }\r\n        }\r\n        this.pauseAfterDisconnect = false;\r\n    }\r\n    updateTranscript({ results, resultIndex }) {\r\n        const currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\r\n        this.interimTranscript = \"\";\r\n        this.finalTranscript = \"\";\r\n        for(let i = currentIndex; i < results.length; ++i){\r\n            if (results[i].isFinal && (!isAndroid() || results[i][0].confidence > 0)) {\r\n                this.updateFinalTranscript(results[i][0].transcript);\r\n            } else {\r\n                this.interimTranscript = concatTranscripts(this.interimTranscript, results[i][0].transcript);\r\n            }\r\n        }\r\n        let isDuplicateResult = false;\r\n        if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\r\n            if (this.previousResultWasFinalOnly) {\r\n                isDuplicateResult = true;\r\n            }\r\n            this.previousResultWasFinalOnly = true;\r\n        } else {\r\n            this.previousResultWasFinalOnly = false;\r\n        }\r\n        if (!isDuplicateResult) {\r\n            this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\r\n        }\r\n    }\r\n    updateFinalTranscript(newFinalTranscript) {\r\n        this.finalTranscript = concatTranscripts(this.finalTranscript, newFinalTranscript);\r\n    }\r\n    resetTranscript() {\r\n        this.disconnect(\"RESET\");\r\n    }\r\n    startListening({ continuous = false, language } = {}) {\r\n        var _this = this;\r\n        return _async_to_generator$1(function*() {\r\n            if (!_this.recognition) {\r\n                return;\r\n            }\r\n            const isContinuousChanged = continuous !== _this.recognition.continuous;\r\n            const isLanguageChanged = language && language !== _this.recognition.lang;\r\n            if (isContinuousChanged || isLanguageChanged) {\r\n                if (_this.listening) {\r\n                    yield _this.stopListening();\r\n                }\r\n                _this.recognition.continuous = isContinuousChanged ? continuous : _this.recognition.continuous;\r\n                _this.recognition.lang = isLanguageChanged ? language : _this.recognition.lang;\r\n            }\r\n            if (!_this.listening) {\r\n                if (!_this.recognition.continuous) {\r\n                    _this.resetTranscript();\r\n                    _this.emitClearTranscript();\r\n                }\r\n                try {\r\n                    yield _this.start();\r\n                    _this.emitListeningChange(true);\r\n                } catch (e) {\r\n                    // DOMExceptions indicate a redundant microphone start - safe to swallow\r\n                    if (!(e instanceof DOMException)) {\r\n                        _this.emitMicrophoneAvailabilityChange(false);\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n    }\r\n    abortListening() {\r\n        var _this = this;\r\n        return _async_to_generator$1(function*() {\r\n            _this.disconnect(\"ABORT\");\r\n            _this.emitListeningChange(false);\r\n            yield new Promise((resolve)=>{\r\n                _this.onStopListening = resolve;\r\n            });\r\n        })();\r\n    }\r\n    stopListening() {\r\n        var _this = this;\r\n        return _async_to_generator$1(function*() {\r\n            _this.disconnect(\"STOP\");\r\n            _this.emitListeningChange(false);\r\n            yield new Promise((resolve)=>{\r\n                _this.onStopListening = resolve;\r\n            });\r\n        })();\r\n    }\r\n    getRecognition() {\r\n        return this.recognition;\r\n    }\r\n    start() {\r\n        var _this = this;\r\n        return _async_to_generator$1(function*() {\r\n            if (_this.recognition && !_this.listening) {\r\n                yield _this.recognition.start();\r\n                _this.listening = true;\r\n            }\r\n        })();\r\n    }\r\n    stop() {\r\n        if (this.recognition && this.listening) {\r\n            this.recognition.stop();\r\n            this.listening = false;\r\n        }\r\n    }\r\n    abort() {\r\n        if (this.recognition && this.listening) {\r\n            this.recognition.abort();\r\n            this.listening = false;\r\n        }\r\n    }\r\n    constructor(SpeechRecognition){\r\n        this.recognition = null;\r\n        this.pauseAfterDisconnect = false;\r\n        this.interimTranscript = \"\";\r\n        this.finalTranscript = \"\";\r\n        this.listening = false;\r\n        this.isMicrophoneAvailable = true;\r\n        this.subscribers = {};\r\n        this.onStopListening = ()=>{};\r\n        this.previousResultWasFinalOnly = false;\r\n        this.resetTranscript = this.resetTranscript.bind(this);\r\n        this.startListening = this.startListening.bind(this);\r\n        this.stopListening = this.stopListening.bind(this);\r\n        this.abortListening = this.abortListening.bind(this);\r\n        this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\r\n        this.disableRecognition = this.disableRecognition.bind(this);\r\n        this.setSpeechRecognition(SpeechRecognition);\r\n        if (isAndroid()) {\r\n            this.updateFinalTranscript = debounce(this.updateFinalTranscript, 250);\r\n        }\r\n    }\r\n}\r\n\r\nconst CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\r\nconst APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\r\n\r\nconst clearTranscript = ()=>{\r\n    return {\r\n        type: CLEAR_TRANSCRIPT\r\n    };\r\n};\r\nconst appendTranscript = (interimTranscript, finalTranscript)=>{\r\n    return {\r\n        type: APPEND_TRANSCRIPT,\r\n        payload: {\r\n            interimTranscript,\r\n            finalTranscript\r\n        }\r\n    };\r\n};\r\n\r\nconst transcriptReducer = (state, action)=>{\r\n    switch(action.type){\r\n        case CLEAR_TRANSCRIPT:\r\n            return {\r\n                interimTranscript: \"\",\r\n                finalTranscript: \"\"\r\n            };\r\n        case APPEND_TRANSCRIPT:\r\n            return {\r\n                interimTranscript: action.payload.interimTranscript,\r\n                finalTranscript: concatTranscripts(state.finalTranscript, action.payload.finalTranscript)\r\n            };\r\n        default:\r\n            throw new Error();\r\n    }\r\n};\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\r\n    try {\r\n        var info = gen[key](arg);\r\n        var value = info.value;\r\n    } catch (error) {\r\n        reject(error);\r\n        return;\r\n    }\r\n    if (info.done) {\r\n        resolve(value);\r\n    } else {\r\n        Promise.resolve(value).then(_next, _throw);\r\n    }\r\n}\r\nfunction _async_to_generator(fn) {\r\n    return function() {\r\n        var self = this, args = arguments;\r\n        return new Promise(function(resolve, reject) {\r\n            var gen = fn.apply(self, args);\r\n            function _next(value) {\r\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\r\n            }\r\n            function _throw(err) {\r\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\r\n            }\r\n            _next(undefined);\r\n        });\r\n    };\r\n}\r\nlet _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\r\nlet _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\r\nlet recognitionManager;\r\nconst useSpeechRecognition = ({ transcribing = true, clearTranscriptOnListen = true, commands = [] } = {})=>{\r\n    const [recognitionManager] = useState(SpeechRecognition.getRecognitionManager());\r\n    const [browserSupportsSpeechRecognition, setBrowserSupportsSpeechRecognition] = useState(_browserSupportsSpeechRecognition);\r\n    const [browserSupportsContinuousListening, setBrowserSupportsContinuousListening] = useState(_browserSupportsContinuousListening);\r\n    const [{ interimTranscript, finalTranscript }, dispatch] = useReducer(transcriptReducer, {\r\n        interimTranscript: recognitionManager.interimTranscript,\r\n        finalTranscript: \"\"\r\n    });\r\n    const [listening, setListening] = useState(recognitionManager.listening);\r\n    const [isMicrophoneAvailable, setMicrophoneAvailable] = useState(recognitionManager.isMicrophoneAvailable);\r\n    const commandsRef = useRef(commands);\r\n    commandsRef.current = commands;\r\n    const dispatchClearTranscript = ()=>{\r\n        dispatch(clearTranscript());\r\n    };\r\n    const resetTranscript = useCallback(()=>{\r\n        recognitionManager.resetTranscript();\r\n        dispatchClearTranscript();\r\n    }, [\r\n        recognitionManager\r\n    ]);\r\n    const testFuzzyMatch = (command, input, fuzzyMatchingThreshold)=>{\r\n        const commandToString = typeof command === \"object\" ? command.toString() : command;\r\n        const commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\r\n        const howSimilar = compareTwoStringsUsingDiceCoefficient(commandWithoutSpecials, input);\r\n        if (howSimilar >= fuzzyMatchingThreshold) {\r\n            return {\r\n                command,\r\n                commandWithoutSpecials,\r\n                howSimilar,\r\n                isFuzzyMatch: true\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    const testMatch = (command, input)=>{\r\n        const pattern = commandToRegExp(command);\r\n        const result = pattern.exec(input);\r\n        if (result) {\r\n            return {\r\n                command,\r\n                parameters: result.slice(1)\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    const matchCommands = useCallback((newInterimTranscript, newFinalTranscript)=>{\r\n        commandsRef.current.forEach(({ command, callback, matchInterim = false, isFuzzyMatch = false, fuzzyMatchingThreshold = 0.8, bestMatchOnly = false })=>{\r\n            const input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\r\n            const subcommands = Array.isArray(command) ? command : [\r\n                command\r\n            ];\r\n            const results = subcommands.map((subcommand)=>{\r\n                if (isFuzzyMatch) {\r\n                    return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\r\n                }\r\n                return testMatch(subcommand, input);\r\n            }).filter((x)=>x);\r\n            if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\r\n                results.sort((a, b)=>b.howSimilar - a.howSimilar);\r\n                const { command, commandWithoutSpecials, howSimilar } = results[0];\r\n                callback(commandWithoutSpecials, input, howSimilar, {\r\n                    command,\r\n                    resetTranscript\r\n                });\r\n            } else {\r\n                results.forEach((result)=>{\r\n                    if (result.isFuzzyMatch) {\r\n                        const { command, commandWithoutSpecials, howSimilar } = result;\r\n                        callback(commandWithoutSpecials, input, howSimilar, {\r\n                            command,\r\n                            resetTranscript\r\n                        });\r\n                    } else {\r\n                        const { command, parameters } = result;\r\n                        callback(...parameters, {\r\n                            command,\r\n                            resetTranscript\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }, [\r\n        resetTranscript\r\n    ]);\r\n    const handleTranscriptChange = useCallback((newInterimTranscript, newFinalTranscript)=>{\r\n        if (transcribing) {\r\n            dispatch(appendTranscript(newInterimTranscript, newFinalTranscript));\r\n        }\r\n        matchCommands(newInterimTranscript, newFinalTranscript);\r\n    }, [\r\n        matchCommands,\r\n        transcribing\r\n    ]);\r\n    const handleClearTranscript = useCallback(()=>{\r\n        if (clearTranscriptOnListen) {\r\n            dispatchClearTranscript();\r\n        }\r\n    }, [\r\n        clearTranscriptOnListen\r\n    ]);\r\n    useEffect(()=>{\r\n        const id = SpeechRecognition.counter;\r\n        SpeechRecognition.counter += 1;\r\n        const callbacks = {\r\n            onListeningChange: setListening,\r\n            onMicrophoneAvailabilityChange: setMicrophoneAvailable,\r\n            onTranscriptChange: handleTranscriptChange,\r\n            onClearTranscript: handleClearTranscript,\r\n            onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\r\n            onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\r\n        };\r\n        recognitionManager.subscribe(id, callbacks);\r\n        return ()=>{\r\n            recognitionManager.unsubscribe(id);\r\n        };\r\n    }, [\r\n        transcribing,\r\n        clearTranscriptOnListen,\r\n        recognitionManager,\r\n        handleTranscriptChange,\r\n        handleClearTranscript\r\n    ]);\r\n    const transcript = concatTranscripts(finalTranscript, interimTranscript);\r\n    return {\r\n        transcript,\r\n        interimTranscript,\r\n        finalTranscript,\r\n        listening,\r\n        isMicrophoneAvailable,\r\n        resetTranscript,\r\n        browserSupportsSpeechRecognition,\r\n        browserSupportsContinuousListening\r\n    };\r\n};\r\nconst SpeechRecognition = {\r\n    counter: 0,\r\n    applyPolyfill: (PolyfillSpeechRecognition)=>{\r\n        if (recognitionManager) {\r\n            recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\r\n        } else {\r\n            recognitionManager = new RecognitionManager(PolyfillSpeechRecognition);\r\n        }\r\n        const browserSupportsPolyfill = !!PolyfillSpeechRecognition && browserSupportsPolyfills();\r\n        _browserSupportsSpeechRecognition = browserSupportsPolyfill;\r\n        _browserSupportsContinuousListening = browserSupportsPolyfill;\r\n    },\r\n    removePolyfill: ()=>{\r\n        if (recognitionManager) {\r\n            recognitionManager.setSpeechRecognition(NativeSpeechRecognition);\r\n        } else {\r\n            recognitionManager = new RecognitionManager(NativeSpeechRecognition);\r\n        }\r\n        _browserSupportsSpeechRecognition = !!NativeSpeechRecognition;\r\n        _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !isAndroid();\r\n    },\r\n    getRecognitionManager: ()=>{\r\n        if (!recognitionManager) {\r\n            recognitionManager = new RecognitionManager(NativeSpeechRecognition);\r\n        }\r\n        return recognitionManager;\r\n    },\r\n    getRecognition: ()=>{\r\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\r\n        return recognitionManager.getRecognition();\r\n    },\r\n    startListening: /*#__PURE__*/ _async_to_generator(function*({ continuous, language } = {}) {\r\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\r\n        yield recognitionManager.startListening({\r\n            continuous,\r\n            language\r\n        });\r\n    }),\r\n    stopListening: /*#__PURE__*/ _async_to_generator(function*() {\r\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\r\n        yield recognitionManager.stopListening();\r\n    }),\r\n    abortListening: /*#__PURE__*/ _async_to_generator(function*() {\r\n        const recognitionManager = SpeechRecognition.getRecognitionManager();\r\n        yield recognitionManager.abortListening();\r\n    }),\r\n    browserSupportsSpeechRecognition: ()=>_browserSupportsSpeechRecognition,\r\n    browserSupportsContinuousListening: ()=>_browserSupportsContinuousListening\r\n};\r\n\r\nexport { SpeechRecognition as default, useSpeechRecognition };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}